---
title: ğŸ”€ Rinnakkaisuus
layout: default
nav_order: 11
permalink: /rinnakkaisuus/
search_exclude: true
nav_exclude: false
---

# Rinnakkaisuus

TÃ¤hÃ¤n saakka kaikki kursseilla tehdyt sovellukset ovat kÃ¤ynnistyneet main-metodin ensimmÃ¤isestÃ¤ lauseesta ja suoritus on edennyt lause kerrallaan kunnes main-metodi on suoritettu kokonaan. Jokaisella hetkellÃ¤ on suorituksessa vain yksi sovelluksen kohta. 
On mahdollista, ettÃ¤ sovelluksen (prosessin) sisÃ¤llÃ¤ on useita samaan aikaan suorituksessa olevia koodinosia, tÃ¤llÃ¶in puhutaan rinnakkaisuudesta.
Rinnakkaisuuden toteutukseen Javassa on kÃ¤ytetty Thread-luokkaa (SÃ¤ie). On olemassa myÃ¶s 'kehittyneempiÃ¤' tapoja rinnakkaisuuden hallintaan, mutta kaikissa tilanteissa alimmaisena kÃ¤sitteenÃ¤ on Thread. 

Miksi rinnakkaisuutta tarvitaan? Yksi syy on suorituskyky, rinnakkain toimivien sÃ¤ikeiden avulla saadaan prosessori paremmin hyÃ¶dynnettyÃ¤ sovelluksen suoritukseen. Toinen aika suoraviivainen tarve lÃ¶ytyy vaikka web-sovelluksien toteutuksesta. Sovellus kÃ¤sittelee selaimelta tulevia pyyntÃ¶jÃ¤ (esim. HTTP-protokollan GET). Sovelluksessa toteutetaan yksittÃ¤isten pyyntÃ¶jen kÃ¤sittely ja varsinainen suoritusympÃ¤ristÃ¶ kÃ¤sittelee samanaikaisesti rinnakkain selaimilta tulevia pyyntÃ¶jÃ¤. Rinnakkaisuuteen liittyy myÃ¶s kÃ¤site asynkronisuus. YleensÃ¤ sillÃ¤ tarkoitetaan metodin kutsumista niin, ettÃ¤ ei kÃ¤Ã¤dÃ¤Ã¤ odottamaan metodin suorituksen pÃ¤Ã¤ttymistÃ¤, vaan kutsuva koodi jatkaa suoritustaan ja mahdollinen paluuarvo kÃ¤sitellÃ¤Ã¤n myÃ¶hemmin. TÃ¤mÃ¤nkin taustalla on sÃ¤ikeet joihin tutustumme seuraavana, selvitellÃ¤Ã¤n rinnakkaisuuteen liittyviÃ¤ sarjallistamisasioita ja poissulkemisongelmaa sekÃ¤ lyhyt katsaus uusiin piirteisiin Javan rinnakkaisuudessa.

Ihan ensimmÃ¤isenÃ¤ tarvitaan joku sopiva esimerkkitoiminta, jonka avulla rinnakkaisuutta ja siihen liittyviÃ¤ asioida voi havainnollistaa koodin avulla. Yksi helppo ja selkeÃ¤ koodi olkoon luokka, jolta voi pyytÃ¤Ã¤ yksilÃ¶llisiÃ¤ numeroita vaikka tuotenumeroiden generointiin. TÃ¤stÃ¤ pÃ¤Ã¤dymme pieneen sivuaskeleeseen eli suunnittelumalleihin (Design Patterns).

### Design Patterns - suunnittelumallit 
Sovelluksian tehtÃ¤essÃ¤ tulee usein esille samankaltaisia ongelmia ja tilanteita. Joka kerta ei tarvitse miettiÃ¤ ratkaisua alusta saakka uudelleen, vaan voidaan kÃ¤yttÃ¤Ã¤ suunnittelumalleja eli Design Patterneja apua. Yleisesti kÃ¤ytetÃ¤Ã¤n englanninkielistÃ¤ termiÃ¤ Design Pattern, vaikka tÃ¤ssÃ¤ tapauksessa suomennos suunnittelumalli on hyvÃ¤. Olio-ohjelmointia on tehty piitkÃ¤Ã¤Ã¤n ja 90-luvulla neljÃ¤n kopla (Gang of Four, GoF) kirjoitti kirjan **Design Patterns: Elements of Reusable Object-Oriented Software** ja siitÃ¤ saakka on Design Pattern-kÃ¤site ollut mukana sovelluskehitysprojekteissa. 

TÃ¤ssÃ¤ ei ole tarkoitus kÃ¤ydÃ¤ enempÃ¤Ã¤ lÃ¤pi erilaisia suunnittelumalleja, vaan ne jÃ¤Ã¤ omatoimisen opiskelun varaan. Seuraavissa koodiesimerkeissÃ¤ kÃ¤ytetty numerogeneraattori toteuttaa Singleton (Ainokainen) suunnittelumallin. Singleton on olio, joita on olemassa vain ja ainoastaan yksi ilmentymÃ¤ koodin suorituksen aikana ja tyypillisesti Singleton on kÃ¤ytÃ¶ssÃ¤ ja nÃ¤kyvissÃ¤ koko sovellukselle.

IDGenerator-luokan koodi:

```java
public class IDGenerator {
    private static int id = 0;
    private static final IDGenerator idg = new IDGenerator();

    private IDGenerator() { } // private, ei siis voi kÃ¤yttÃ¤Ã¤ luokan ulkopuolelta

    public static IDGenerator getIDGenerator() { // tÃ¤llÃ¤ pyydetÃ¤Ã¤n viittaus ainokaiseen
        return idg;
    }

    public int nextID() {
        return ++id;
    }

    public int getLastId() {
        return id;
    }
}
```
Kun sovelluskoodissa tarvitaan yksilÃ¶llinen kokonaisluku, esimerkiksi avaimen generoimiseksi oliolle, voidaan missÃ¤ tahansa koodissa tehdÃ¤ se IDGenerator-luokan avulla.

```java
IDGenerator idg = IDGenerator.getIDGenerator();
int id = idg.nextID();
```

Sitten siirrytÃ¤Ã¤n takaisin rinnakkaiseen ohjelmointiin ja kÃ¤ytetÃ¤Ã¤n tÃ¤tÃ¤ luokkaa apuna.

---

### Thread - SÃ¤ie

Javassa sÃ¤ie on lyhyesti sanottuna metodi (void run()), joka on suorituksessa itsenÃ¤isesti samaan aikaan (rinnakkain) muiden sÃ¤ikeiden kanssa. SÃ¤ikeen luonnissa konstruktorin parametrina annetaan Runnable-tyyppinen olio. Runnable on rajapinta (FunctionalInterface), joten tÃ¤ssÃ¤kin voi kÃ¤yttÃ¤Ã¤ lambda-lauseketta. Seuraavana yksinkertainen esimerkki, jossa sÃ¤ie ei tee mitÃ¤Ã¤n muuta kuin tulostaa sÃ¤ikeen nimen. Sen avulla on helppo nÃ¤hdÃ¤, ettÃ¤ samaan aikaan on suorituksessa useita sÃ¤ikeitÃ¤. Jokainen sÃ¤ie voi suorittaa eri metodia, tÃ¤ssÃ¤ esimerkissÃ¤ kaikki ovat samoja.

```java
Runnable run = () -> System.out.println("KÃ¤ynnistetty sÃ¤ie: " + Thread.currentThread().getName());
System.out.println("PÃ¤Ã¤sÃ¤ie: " + Thread.currentThread().getName());
Thread t = new Thread(run);
t.start();
for (int i = 0; i < 5; i++) {
    new Thread(run).start();
}
```

Saman voi kirjoittaa lyhyemmin kÃ¤yttÃ¤mÃ¤llÃ¤ lambda-syntaksia.

```java
// lambda kÃ¤ytÃ¶ssÃ¤
System.out.println("PÃ¤Ã¤sÃ¤ie: " + Thread.currentThread().getName());
Thread t = new Thread(() -> System.out.println("KÃ¤ynnistetty sÃ¤ie: " + Thread.currentThread().getName()));
t.start();
for (int i = 0; i < 5; i++) {
    new Thread(run).start();
}
```

Ja jos kÃ¤ytetÃ¤Ã¤n luokassa olevaa run()-metodia:

```java
Thread t3 = new Thread(new DemoSÃ¤ie() );
t3.start();

// luokka joka toteuttaa Runnable-rajapinnan
class DemoSÃ¤ie implements Runnable {
    @Override
    public void run() {
        System.out.println("Luokka ja sÃ¤iemetodi: " + Thread.currentThread().getName());
    }
}
```
Usein on tarpeen tietÃ¤Ã¤ milloin sÃ¤ie on pÃ¤Ã¤ttynyt. SÃ¤ikeen suoritus pÃ¤Ã¤ttyy, kun run()-metodi on suoritettu tai koodi kaatuu virheeseen. SÃ¤ie ei ilmoita pÃ¤Ã¤ttymisestÃ¤ silloin kun kÃ¤ytetÃ¤Ã¤n sÃ¤ikeitÃ¤ tÃ¤hÃ¤n mennessÃ¤ nÃ¤kyvien esimerkkien mukaisesti. On olemassa myÃ¶s toimintomalli, jossa saadaan ilmoitus kÃ¤ynnistÃ¤vÃ¤lle koodille sÃ¤ikeen pÃ¤Ã¤ttymisestÃ¤. Muutoin on vaihtoehtona kysyÃ¤ pollaamalla sÃ¤ikeen tilaa tai 'liittyÃ¤' sÃ¤ikeeseen join()-metodilla. NÃ¤issÃ¤ pitÃ¤Ã¤ huolehtia mahdollisesta poikkeuksesta. Metodi sleep() aiheuttaa sÃ¤ikeen siirtymisen pois suorituksesta parametrina olevan millisekuntimÃ¤Ã¤rÃ¤n ajaksi. Pollaavassa versiossa kannattaa odottaa tovi ennen kuin kysyy uudelleen sÃ¤ikeen tilaa isAlive()-metodilla. Pollaus tarkoittaa sitÃ¤, ettÃ¤ kysytÃ¤Ã¤n (poll) sÃ¤ikeen tilaa, koodissa siis aktiivisesti seurataan sÃ¤ikeen suorituksen tilaa. 

```java
while (t3.isAlive()) { // join() on parempi!
    try {
        Thread.sleep(100);
    } catch (InterruptedException e) {
    }
}
System.out.println("SÃ¤ie 3 pÃ¤Ã¤ttynyt");
try {
    t2.join();
} catch (InterruptedException e) {
}
System.out.println("SÃ¤ie 2 pÃ¤Ã¤ttynyt");
```

Testataan seuraavana miten numeroiden generointi onnistuu useasta eri sÃ¤ikeestÃ¤ ja toimiiko IDGenerator-luokka kuten halutaan. SitÃ¤ varten tehdÃ¤Ã¤n uusi luokka IDConsumer:

```java
public class IDConsumer implements Runnable {

    private int counter; // montako kertaan pyydetÃ¤Ã¤n uusi ID
    private boolean useDelay; // simuloidaanko kuormaa viiveellÃ¤

    public IDConsumer(int counter, boolean useDelay) {
        this.counter = counter;
        this.useDelay = useDelay;
    }

    @Override
    public void run() {
        Random rnd = new Random();
        IDGenerator idg = IDGenerator.getIDGenerator();
        int id = 0; 
        for (int i = 0; i < counter; i++) {
            id = idg.nextID();
            if (useDelay) {
                try {
                    Thread.sleep(rnd.nextInt(50));
                } catch (InterruptedException e) {
                    // just do nothing...
                }
            }
        }
    }
}
```

Nyt kokeillaan ensimmÃ¤isen kerran seuraavalla koodilla ja kaikki nÃ¤yttÃ¤Ã¤ olevan kunnossa.

```java
IDConsumer idc1 = new IDConsumer(5, false);
IDConsumer idc2 = new IDConsumer(5, false);
Thread t1 = new Thread(idc1);
Thread t2 = new Thread(idc2);
t1.start();
t2.start();
try {
    t1.join();
    t2.join();
} catch (InterruptedException e) {
}
IDGenerator idg = IDGenerator.getIDGenerator();
// seuraava id pitÃ¤isi olla 2 kertaa 5 eli 10
int id = idg.getLastId();
System.out.println("ID: " + id); // tulostaa ID: 10 
```
Todellisuudessa tÃ¤mÃ¤ koodi toimii vain vahingossa oikein. Jos lisÃ¤tÃ¤Ã¤n kierrosten lukumÃ¤Ã¤rÃ¤Ã¤, alkaa laskuri tuottaa outoja arvoja. IDGenerator-luokan nextID()-metodi nÃ¤yttÃ¤Ã¤ tekevÃ¤n vain yhden operaation. NÃ¤in ei kuitenkaan ole, vaan suorituksen aikana kokonaisluvun kasvattaminen on monta erillistÃ¤ kÃ¤skyÃ¤ prosessoritasolla. SÃ¤ikeitÃ¤ suoritetaan aika aikaviipale kerrallaan (jÃ¤rjestelmÃ¤n pÃ¤Ã¤ttÃ¤mÃ¤ aika ja prioriteetit vaikuttaa myÃ¶s). Jos aikaviipale pÃ¤Ã¤ttyy kesken muuttujan pÃ¤ivityksen ja toinen sÃ¤ie pÃ¤Ã¤see suoritukseen, osa pÃ¤ivitysoperaatioista 'katoaa'. TÃ¤mÃ¤ riski on aina mahdollista, kun eri sÃ¤ikeistÃ¤ kÃ¤sitellÃ¤Ã¤n samaa muuttujaa (olion kenttÃ¤Ã¤).

Olemme pÃ¤Ã¤tyneet tilanteeseen, josta kÃ¤ytetÃ¤Ã¤n termiÃ¤ Critical Section (kriittinen alue). Critical section on koodia, joka pitÃ¤Ã¤ suorittaa sÃ¤ikeessÃ¤ atomaarisesti niin, ettei muut sÃ¤ikeet pÃ¤Ã¤se suorittamaan samaa koodia tai kÃ¤sittelemÃ¤Ã¤n samaa muuttujaa. Javassa tÃ¤hÃ¤n on ollut yksinkertainen ratkaisu olemassa jo aivan ensimmÃ¤isestÃ¤ versiosta saakka ja se on synchronized sanalla toteutettavissa. Synchronized-toiminnolla saadaan lukittua koodilohko tai kokonainen metodi niin, ettÃ¤ sÃ¤ie saa suorittaa metodin tai koodilohkon loppuun saakka ilman ettÃ¤ mikÃ¤Ã¤n muu sÃ¤ie pÃ¤Ã¤see suorittamaan samaa koodia. 

Koodilohkoa kÃ¤ytettÃ¤essÃ¤ tarvitaan jokin olio lukitukseen. Jokaisessa Java-oliossa on sisÃ¤Ã¤nrakennettu lukko-bitti, joka ei nÃ¤y mitenkÃ¤Ã¤n, vaan se pitÃ¤Ã¤ tietÃ¤Ã¤. 
Turvallinen ja toimiva nextID()-metodin toteutus voi olla seuraava:

```java
private static Object mutex = new Object();
public int nextID() {
    synchronized (mutex) {
        return ++id;
     }
}
```

Jos koko metodin koodi halutaan suorittaa synkronoituna, voidaan kÃ¤yttÃ¤Ã¤ lyhennettyÃ¤ versiota ja koko metodi merkitÃ¤ synkronoiduksi:

```java
public synchronized int nextID() {
    return ++id;
}
```

Nyt korjattu versio toimii kaikissa tilanteissa oikein. SÃ¤ikeiden kÃ¤ynnistÃ¤minen ei ole vaikeaa, huomattavasti hankalampaa on niiden hallinnointi, lÃ¶ytÃ¤Ã¤ sopivat kÃ¤yttÃ¶tilanteet ja ymmÃ¤rtÃ¤Ã¤ seuraamukset vaikka yhteisten muuttujien kÃ¤sittelyn osalta.

SÃ¤ikeet ovat perusrakenne rinnakkaisuuden toteutuksessa. Valitettavasti ominaisuudet ovat myÃ¶s rajalliset ja jos sÃ¤ikeen run()-metodille pitÃ¤isi vÃ¤littÃ¤Ã¤ parametreja tai sen pitÃ¤isi palauttaa arvo, loppuu ominaisuudet kesken. Onneksi on myÃ¶s edistyneempiÃ¤ tapoja tehdÃ¤ rinnakkaisuutta kÃ¤yttÃ¤llÃ¤ Executor-luokkaa hyvÃ¤ksi.  

Tutustu esimerkkikoodiin, jossa on kÃ¤ytetty ExecutorService:Ã¤ ja Future-luokkaa:

```java
public class AppExecutor {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        int threadCount = 5;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        List<Callable<Integer>> threads = new ArrayList<>();
        for (int i = 0; i < threadCount; i++) {
            threads.add(new IDConsumerCallable(10));
        }
        List<Future<Integer>> futures = executor.invokeAll(threads);
        IDGenerator idGenerator = IDGenerator.getIDGenerator();
        int id = idGenerator.getLastId();
        System.out.println("ID: " + id);
        id = 0;
        for (Future<Integer> future : futures) {
            id = future.get();
            System.out.println("ID sÃ¤ikeen pÃ¤Ã¤ttyessÃ¤: " + id);
        }
    }
}

class IDConsumerCallable implements Callable<Integer> {

    private int counter = 1000;

    public IDConsumerCallable(int counter) {
        this.counter = counter;
    }

    @Override
    public Integer call() throws Exception {
        IDGenerator idg = IDGenerator.getIDGenerator();
        System.out.println("Callable starting...");
        int id = 0; 
        for (int i = 0; i < counter; i++) {
            id = idg.nextID();
            System.out.println("\t" + this.toString() + " " + id);
        }
        System.out.println(this.toString() + " " + id + " counter: " + counter);
        return id;
    }
}
```

TÃ¤mÃ¤ ei ole kattava kokonaisuus Javan rinnakkaisuudesta, oleellisinta on saada perusteista kÃ¤sitys ja varsinkin miksi synchronized varattua sanaa pitÃ¤Ã¤ kÃ¤yttÃ¤Ã¤ ja miten.
LisÃ¤Ã¤ aiheesta lÃ¶ytyy mm.:
* [dev.java](https://dev.java/learn/new-features/virtual-threads/) 
* [oracle](https://docs.oracle.com/javase/tutorial/essential/concurrency/) 
* [baeldung](https://www.baeldung.com/java-concurrency) 
* [w3schools](https://www.w3schools.com/java/java_threads.asp)

{% include quiz.html %}
